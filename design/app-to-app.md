App to App Interactions
===========

This document describes an extension to the SDK to allow MRE apps to receive content (e.g., photos) from the MRE clients. Content may be generated by the client itself, or, in future iterations not yet described here, may arrive from other apps with coordination from a particular client.

## API Design
This design introduces the concept of a `SharingMessage`, a base class of content-specific messages, such as `PhotoSharingMessage`. We provide an outline for the implementation of `PhotoSharingMessage` only, but expect to add more sharing capabilities over time.

`SharingMessage` is itself relatively straightforward, but contains enough information to allow the recipient (callback listener) to cast it to the appropriate type (e.g., `PhotoSharingMessage`). We envision multiple message types and don't want to add a registration api for each.

```ts
class SharingMessage {
    messageType: Readonly<string>;
    sessionId: Readonly<string>;
    userId: Readonly<Guid>;
}

class PhotoSharingMessage extends SharingMessage {
    photoType: Readonly<string>; // Supported values: "jpg" and "png"
    data: Readonly<Buffer>; // Raw bytes of an image file in the photoType format above
}
```

`SharingCallbacks` are a relatively straightforward callback registration mechanism, with an optional mechanism to allow the callback registrant to stop processing of messages and construction of payloads in cases where a particular message would not be acted on.

```ts

// Fires before the MessageReceivedCallback. When the implementation
// returns false, may short-circuit additional processing on the message.
// Note that this callback is optional but may be useful if the
// application is unable or uninterested in acting on all messages.
interface IsMessageDesiredCallback { 
    (sessionId: string, userId: Guid) : bool
}

interface MessageReceivedCallback {
    (sharingMessage: SharingMessage) : void
}

class SharingCallbacks {
    // Note that this callback is optional (See IsMessageDesiredCallback).
    // Leave null to process all messages 
    public isMessageDesired : IsMessageDesiredCallback;
    public messageReceived : MessageReceivedCallback;
}
```

Callbacks are registered (and deregistered) via new functions on the context described below. Optionally, callbacks may be scoped to a particular session id or user id. When no session or user id is provided, sharing data will be accepted from any session and user.

For the sake of simplicity, only one callback may be registered for a given ```<MessageType,UserId>``` on a particular session context at a time. This restriction may allow for a more simple bookeeping implementation for registered callbacks within the the sharing implementation on both the app side and the client runtime See [Implementation Suggestions](#Implementation\ Suggestions)

```ts
// Modifications to
// https://github.com/microsoft/mixed-reality-extension-sdk/blob/master/packages/sdk/src/core/context.ts

/**
 * Registers a set of callbacks invoked at various points in the processing
 * of a sharing message. Only one callback may be registered at a time for a 
 * given context and user.
 * 
 * Use ZeroGuid to register for all users.
 * 
 * Returns true if the callback was successfully registered.
 * @event
 */
public onSharingMessage(userId: Guid, callbacks: SharingCallbacks): bool {
    // [... Register listener ...]
    return true; // If successful
}

/**
 * Removes the onSharingMessage callback, if any, associated with the given user from the context.
 * 
 * Returns true if the callback was successfully unregistered.
 * @event
 */
public offSharingMessage(userId: Guid): bool {
    // [... Deregister listener ...]
    return true; // If successful
}
```

## Implementation Suggestions

1. Modify `context` to expose callback registration mechanism
2. Adjust `contextInternal` and perhaps `multiPeerAdapter` to message the desire for each MessageType callback to each client (and corresponding remove messages). For callbacks registered for all sessions or all users, this my be sent after connect
3. Implement the "Photo" message type. Send and receive encoded photos via the existing websocket used by multiPeerAdapter. Future message types (e.g., streaming video) may need to establish related side-channels.